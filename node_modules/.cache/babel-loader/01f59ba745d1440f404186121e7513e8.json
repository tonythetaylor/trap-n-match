{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t(require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"react\"], t) : \"object\" == typeof exports ? exports[\"react-socks\"] = t(require(\"react\")) : e[\"react-socks\"] = t(e.react);\n}(this, function (e) {\n  return function (e) {\n    var t = {};\n\n    function n(r) {\n      if (t[r]) return t[r].exports;\n      var o = t[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, r) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: r\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var r = Object.create(null);\n      if (n.r(r), Object.defineProperty(r, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var o in e) {\n        n.d(r, o, function (t) {\n          return e[t];\n        }.bind(null, o));\n      }\n      return r;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 6);\n  }([function (t, n) {\n    t.exports = e;\n  }, function (e, t, n) {\n    e.exports = n(3)();\n  }, function (e, t, n) {\n    \"use strict\";\n\n    (function (e) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n      var n = \"undefined\" != typeof window && void 0 !== window.document,\n          r = void 0 !== e && null != e.versions && null != e.versions.node;\n      t.isBrowser = n, t.isNode = r;\n    }).call(this, n(5));\n  }, function (e, t, n) {\n    \"use strict\";\n\n    var r = n(4);\n\n    function o() {}\n\n    e.exports = function () {\n      function e(e, t, n, o, i, u) {\n        if (u !== r) {\n          var a = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\");\n          throw a.name = \"Invariant Violation\", a;\n        }\n      }\n\n      function t() {\n        return e;\n      }\n\n      e.isRequired = e;\n      var n = {\n        array: e,\n        bool: e,\n        func: e,\n        number: e,\n        object: e,\n        string: e,\n        symbol: e,\n        any: e,\n        arrayOf: t,\n        element: e,\n        instanceOf: t,\n        node: e,\n        objectOf: t,\n        oneOf: t,\n        oneOfType: t,\n        shape: t,\n        exact: t\n      };\n      return n.checkPropTypes = o, n.PropTypes = n, n;\n    };\n  }, function (e, t, n) {\n    \"use strict\";\n\n    e.exports = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n  }, function (e, t) {\n    var n,\n        r,\n        o = e.exports = {};\n\n    function i() {\n      throw new Error(\"setTimeout has not been defined\");\n    }\n\n    function u() {\n      throw new Error(\"clearTimeout has not been defined\");\n    }\n\n    function a(e) {\n      if (n === setTimeout) return setTimeout(e, 0);\n      if ((n === i || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0);\n\n      try {\n        return n(e, 0);\n      } catch (t) {\n        try {\n          return n.call(null, e, 0);\n        } catch (t) {\n          return n.call(this, e, 0);\n        }\n      }\n    }\n\n    !function () {\n      try {\n        n = \"function\" == typeof setTimeout ? setTimeout : i;\n      } catch (e) {\n        n = i;\n      }\n\n      try {\n        r = \"function\" == typeof clearTimeout ? clearTimeout : u;\n      } catch (e) {\n        r = u;\n      }\n    }();\n    var c,\n        f = [],\n        l = !1,\n        s = -1;\n\n    function p() {\n      l && c && (l = !1, c.length ? f = c.concat(f) : s = -1, f.length && y());\n    }\n\n    function y() {\n      if (!l) {\n        var e = a(p);\n        l = !0;\n\n        for (var t = f.length; t;) {\n          for (c = f, f = []; ++s < t;) {\n            c && c[s].run();\n          }\n\n          s = -1, t = f.length;\n        }\n\n        c = null, l = !1, function (e) {\n          if (r === clearTimeout) return clearTimeout(e);\n          if ((r === u || !r) && clearTimeout) return r = clearTimeout, clearTimeout(e);\n\n          try {\n            r(e);\n          } catch (t) {\n            try {\n              return r.call(null, e);\n            } catch (t) {\n              return r.call(this, e);\n            }\n          }\n        }(e);\n      }\n    }\n\n    function d(e, t) {\n      this.fun = e, this.array = t;\n    }\n\n    function h() {}\n\n    o.nextTick = function (e) {\n      var t = new Array(arguments.length - 1);\n      if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) {\n        t[n - 1] = arguments[n];\n      }\n      f.push(new d(e, t)), 1 !== f.length || l || a(y);\n    }, d.prototype.run = function () {\n      this.fun.apply(null, this.array);\n    }, o.title = \"browser\", o.browser = !0, o.env = {}, o.argv = [], o.version = \"\", o.versions = {}, o.on = h, o.addListener = h, o.once = h, o.off = h, o.removeListener = h, o.removeAllListeners = h, o.emit = h, o.prependListener = h, o.prependOnceListener = h, o.listeners = function (e) {\n      return [];\n    }, o.binding = function (e) {\n      throw new Error(\"process.binding is not supported\");\n    }, o.cwd = function () {\n      return \"/\";\n    }, o.chdir = function (e) {\n      throw new Error(\"process.chdir is not supported\");\n    }, o.umask = function () {\n      return 0;\n    };\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t);\n    var r = n(0),\n        o = n.n(r),\n        i = n(1),\n        u = n.n(i),\n        a = n(2);\n\n    function c(e) {\n      return (c = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    function f(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var r = t[n];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n      }\n    }\n\n    var l = new (function () {\n      function e() {\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, e);\n        this.allBreakpoints = [{\n          xsmall: 0\n        }, {\n          small: 576\n        }, {\n          medium: 768\n        }, {\n          large: 992\n        }, {\n          xlarge: 1200\n        }];\n      }\n\n      return function (e, t, n) {\n        t && f(e.prototype, t), n && f(e, n);\n      }(e, [{\n        key: \"getBreakpointName\",\n        value: function value(e) {\n          var t;\n          return this.allBreakpoints.forEach(function (n) {\n            var r = Object.keys(n)[0];\n            n[r] <= e && (t = r);\n          }), t;\n        }\n      }, {\n        key: \"getBreakpointWidth\",\n        value: function value(e) {\n          var t = 0;\n          return this.allBreakpoints.forEach(function (n) {\n            var r = Object.keys(n)[0];\n            r === e && (t = n[r]);\n          }), t;\n        }\n      }, {\n        key: \"getNextBreakpointWidth\",\n        value: function value(e) {\n          for (var t = 9999, n = 0, r = 0; r < this.allBreakpoints.length; r++) {\n            var o = this.allBreakpoints[r];\n\n            if (Object.keys(o)[0] === e && (n = r), n > 0) {\n              var i = n + 1;\n\n              if (this.allBreakpoints.length > i) {\n                var u = this.allBreakpoints[i];\n                t = u[Object.keys(u)[0]];\n              }\n\n              break;\n            }\n          }\n\n          return t;\n        }\n      }, {\n        key: \"shouldRender\",\n        value: function value(e) {\n          var t = e.breakpointName,\n              n = e.modifier,\n              r = e.currentBreakpointName,\n              o = e.currentWidth;\n\n          if (\"only\" === n) {\n            if (t === r) return !0;\n          } else if (\"up\" === n) {\n            if (o >= this.getBreakpointWidth(t)) return !0;\n          } else if (\"down\" === n) {\n            if (o < this.getNextBreakpointWidth(t)) return !0;\n          }\n\n          return !1;\n        }\n      }, {\n        key: \"getWidthSafely\",\n        value: function value() {\n          return a.isBrowser && window ? Math.max(document.documentElement.clientWidth, window.innerWidth || 0) : 9999;\n        }\n      }, {\n        key: \"currentWidth\",\n        get: function get() {\n          return this.getWidthSafely();\n        }\n      }, {\n        key: \"breakpoints\",\n        set: function set(e) {\n          this.allBreakpoints = e;\n        }\n      }]), e;\n    }())(),\n        s = l,\n        p = function p(e) {\n      if (!(e && \"object\" === c(e) && e instanceof Array)) throw new Error(\"setDefaultBreakpoints error: Breakpoints should be an array\");\n      e.forEach(function (e) {\n        if (!e || \"object\" !== c(e)) throw new Error(\"setDefaultBreakpoints error: Breakpoints should be an array of objects\");\n        if (1 !== Object.keys(e).length) throw new Error(\"setDefaultBreakpoints error: Each breakpoint object should have only one key\");\n      }), l.breakpoints = e;\n    };\n\n    function y(e) {\n      return (y = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    function d(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var r = t[n];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n      }\n    }\n\n    function h(e) {\n      return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n\n    function b(e, t) {\n      return (b = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n\n    function m(e) {\n      if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return e;\n    }\n\n    var v = o.a.createContext(),\n        k = function (e) {\n      function t(e) {\n        var n;\n        !function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, t), n = function (e, t) {\n          return !t || \"object\" !== y(t) && \"function\" != typeof t ? m(e) : t;\n        }(this, h(t).call(this, e));\n        var r = s.currentWidth;\n        return n.state = {\n          currentWidth: r,\n          currentBreakpointName: s.getBreakpointName(r)\n        }, n.handleResize = n.handleResize.bind(m(m(n))), n;\n      }\n\n      return function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && b(e, t);\n      }(t, o.a.Component), function (e, t, n) {\n        t && d(e.prototype, t), n && d(e, n);\n      }(t, [{\n        key: \"componentDidMount\",\n        value: function value() {\n          window.addEventListener(\"resize\", this.handleResize);\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function value() {\n          window.removeEventListener(\"resize\", this.handleResize);\n        }\n      }, {\n        key: \"handleResize\",\n        value: function value() {\n          var e = s.currentWidth;\n          this.setState({\n            currentWidth: e,\n            currentBreakpointName: s.getBreakpointName(e)\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function value() {\n          var e = this.props.children,\n              t = this.state,\n              n = t.currentWidth,\n              r = t.currentBreakpointName;\n          return o.a.createElement(v.Provider, {\n            value: {\n              currentWidth: n,\n              currentBreakpointName: r\n            }\n          }, e);\n        }\n      }]), t;\n    }();\n\n    function w(e) {\n      return (w = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    function O(e, t) {\n      if (null == e) return {};\n\n      var n,\n          r,\n          o = function (e, t) {\n        if (null == e) return {};\n        var n,\n            r,\n            o = {},\n            i = Object.keys(e);\n\n        for (r = 0; r < i.length; r++) {\n          n = i[r], t.indexOf(n) >= 0 || (o[n] = e[n]);\n        }\n\n        return o;\n      }(e, t);\n\n      if (Object.getOwnPropertySymbols) {\n        var i = Object.getOwnPropertySymbols(e);\n\n        for (r = 0; r < i.length; r++) {\n          n = i[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);\n        }\n      }\n\n      return o;\n    }\n\n    function g(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var r = t[n];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n      }\n    }\n\n    function j(e) {\n      return (j = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      })(e);\n    }\n\n    function B(e, t) {\n      return (B = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      })(e, t);\n    }\n\n    function T(e) {\n      if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return e;\n    }\n\n    k.propTypes = {\n      children: u.a.node\n    };\n\n    var _ = function (e) {\n      function t(e) {\n        var n;\n        return function (e, t) {\n          if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, t), (n = function (e, t) {\n          return !t || \"object\" !== w(t) && \"function\" != typeof t ? T(e) : t;\n        }(this, j(t).call(this, e))).extractBreakpointAndModifierFromProps = n.extractBreakpointAndModifierFromProps.bind(T(T(n))), n;\n      }\n\n      return function (e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && B(e, t);\n      }(t, o.a.Component), function (e, t, n) {\n        t && g(e.prototype, t), n && g(e, n);\n      }(t, [{\n        key: \"extractBreakpointAndModifierFromProps\",\n        value: function value(e) {\n          var t, n;\n          return Object.keys(e).forEach(function (e) {\n            \"up\" === e || \"down\" === e || \"only\" === e ? n = e : t = e;\n          }), n || (n = \"only\"), {\n            breakpoint: t,\n            modifier: n\n          };\n        }\n      }, {\n        key: \"render\",\n        value: function value() {\n          var e = this.props,\n              t = e.children,\n              n = O(e, [\"children\"]),\n              r = this.extractBreakpointAndModifierFromProps(n),\n              i = r.breakpoint,\n              u = r.modifier,\n              a = this.context,\n              c = a.currentBreakpointName,\n              f = a.currentWidth;\n          return s.shouldRender({\n            breakpointName: i,\n            modifier: u,\n            currentBreakpointName: c,\n            currentWidth: f\n          }) ? o.a.createElement(\"div\", {\n            className: \"breakpoint__\".concat(i, \"-\").concat(u)\n          }, t) : null;\n        }\n      }]), t;\n    }();\n\n    _.contextType = v, _.propTypes = {\n      children: u.a.node,\n      up: u.a.bool,\n      down: u.a.bool,\n      only: u.a.bool\n    }, n.d(t, \"Breakpoint\", function () {\n      return _;\n    }), n.d(t, \"BreakpointProvider\", function () {\n      return k;\n    }), n.d(t, \"setDefaultBreakpoints\", function () {\n      return p;\n    });\n    t.default = _;\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}